// generated by nodegen.py; do not edit

#pragma once

#include <string_view>
#include <memory>
#include <vector>

#include "visitor.h"
#include "syntax/token.h"
#include "semantic/symdata.h"

struct Node
{
	virtual void accept(Visitor &v) = 0;
};
struct Expression : public Node
{
};
struct Statement : public Node
{
};
struct Program : public Node
{
	std::vector<std::unique_ptr<Statement>> statements;
	Program(std::vector<std::unique_ptr<Statement>> statements);
	void accept(Visitor &v) override;
};
struct ExprStatement : public Statement
{
	std::unique_ptr<Expression> expr;
	ExprStatement(std::unique_ptr<Expression> expr);
	void accept(Visitor &v) override;
};
struct VariableDef : public Statement
{
	std::unique_ptr<Identifier> name;
	std::unique_ptr<Type> type;
	std::unique_ptr<Expression> value;
	VariableDef(std::unique_ptr<Identifier> name, std::unique_ptr<Type> type, std::unique_ptr<Expression> value);
	void accept(Visitor &v) override;
};
struct FunctionDef : public Statement
{
	std::unique_ptr<Identifier> name;
	std::vector<std::unique_ptr<Parameter>> parameters;
	std::unique_ptr<Type> return_type;
	std::unique_ptr<Block> body;
	FunctionDef(std::unique_ptr<Identifier> name, std::vector<std::unique_ptr<Parameter>> parameters, std::unique_ptr<Type> return_type, std::unique_ptr<Block> body);
	void accept(Visitor &v) override;
};
struct Value : public Expression
{
	Token token;
	Value(Token token);
};
struct Literal : public Value
{
	using Value::Value;
};
struct NumberLiteral : public Literal
{
	using Literal::Literal;
	void accept(Visitor &v) override;
};
struct StringLiteral : public Literal
{
	using Literal::Literal;
	void accept(Visitor &v) override;
};
struct BooleanLiteral : public Literal
{
	using Literal::Literal;
	void accept(Visitor &v) override;
};
struct UnitLiteral : public Literal
{
	using Literal::Literal;
	void accept(Visitor &v) override;
};
struct Identifier : public Value
{
	std::shared_ptr<SymbolData> symbol;
	Identifier(Token token, std::shared_ptr<SymbolData> symbol);
	void accept(Visitor &v) override;
};
struct FunctionCall : public Expression
{
	std::unique_ptr<Identifier> name;
	std::vector<std::unique_ptr<Expression>> arguments;
	FunctionCall(std::unique_ptr<Identifier> name, std::vector<std::unique_ptr<Expression>> arguments);
	void accept(Visitor &v) override;
};
struct Operator : public Expression
{
	Token token;
	Operator(Token token);
};
struct InfixOperator : public Operator
{
	std::unique_ptr<Expression> left;
	std::unique_ptr<Expression> right;
	InfixOperator(Token token, std::unique_ptr<Expression> left, std::unique_ptr<Expression> right);
	void accept(Visitor &v) override;
};
struct PrefixOperator : public Operator
{
	std::unique_ptr<Expression> operand;
	PrefixOperator(Token token, std::unique_ptr<Expression> operand);
	void accept(Visitor &v) override;
};
struct PostfixOperator : public Operator
{
	std::unique_ptr<Expression> operand;
	PostfixOperator(Token token, std::unique_ptr<Expression> operand);
	void accept(Visitor &v) override;
};
struct ReturnExpr : public Expression
{
	std::unique_ptr<Expression> value;
	ReturnExpr(std::unique_ptr<Expression> value);
	void accept(Visitor &v) override;
};
struct IfExpr : public Expression
{
	std::unique_ptr<Expression> condition;
	std::unique_ptr<Block> if_branch;
	std::unique_ptr<Block> else_branch;
	IfExpr(std::unique_ptr<Expression> condition, std::unique_ptr<Block> if_branch, std::unique_ptr<Block> else_branch);
	void accept(Visitor &v) override;
};
struct WhileExpr : public Expression
{
	std::unique_ptr<Expression> condition;
	std::unique_ptr<Block> body;
	WhileExpr(std::unique_ptr<Expression> condition, std::unique_ptr<Block> body);
	void accept(Visitor &v) override;
};
struct Invalid : public Node
{
	void accept(Visitor &v) override;
};
struct Block : public Statement
{
	std::vector<std::unique_ptr<Statement>> statements;
	Block(std::vector<std::unique_ptr<Statement>> statements);
	void accept(Visitor &v) override;
};
struct Parameter : public Node
{
	std::unique_ptr<Identifier> name;
	std::unique_ptr<Type> type;
	Parameter(std::unique_ptr<Identifier> name, std::unique_ptr<Type> type);
	void accept(Visitor &v) override;
};
struct Type : public Node
{
	Token token;
	Type(Token token);
	void accept(Visitor &v) override;
};
