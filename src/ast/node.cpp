// generated by nodegen.py; do not edit

#include "node.h"

Program::Program(std::vector<std::unique_ptr<Statement>> statements)
	: statements(std::move(statements))
{
}
void Program::accept(Visitor &v)
{
	v.visit(*this);
}
ExprStatement::ExprStatement(std::unique_ptr<Expression> expr)
	: expr(std::move(expr))
{
}
void ExprStatement::accept(Visitor &v)
{
	v.visit(*this);
}
VariableDef::VariableDef(std::unique_ptr<Identifier> name, std::unique_ptr<Type> type, std::unique_ptr<Expression> value)
	: name(std::move(name)), type(std::move(type)), value(std::move(value))
{
}
void VariableDef::accept(Visitor &v)
{
	v.visit(*this);
}
FunctionDef::FunctionDef(std::unique_ptr<Identifier> name, std::vector<std::unique_ptr<Parameter>> parameters, std::unique_ptr<Type> return_type, std::unique_ptr<Block> body)
	: name(std::move(name)), parameters(std::move(parameters)), return_type(std::move(return_type)), body(std::move(body))
{
}
void FunctionDef::accept(Visitor &v)
{
	v.visit(*this);
}
Value::Value(Token token)
	: token(token)
{
}
void NumberLiteral::accept(Visitor &v)
{
	v.visit(*this);
}
void StringLiteral::accept(Visitor &v)
{
	v.visit(*this);
}
void BooleanLiteral::accept(Visitor &v)
{
	v.visit(*this);
}
void UnitLiteral::accept(Visitor &v)
{
	v.visit(*this);
}
Identifier::Identifier(Token token, std::shared_ptr<SymbolData> symbol)
	: Value(token), symbol(symbol)
{
}
void Identifier::accept(Visitor &v)
{
	v.visit(*this);
}
FunctionCall::FunctionCall(std::unique_ptr<Identifier> name, std::vector<std::unique_ptr<Expression>> arguments, Token rparen)
	: name(std::move(name)), arguments(std::move(arguments)), rparen(rparen)
{
}
void FunctionCall::accept(Visitor &v)
{
	v.visit(*this);
}
Operator::Operator(Token token)
	: token(token)
{
}
InfixOperator::InfixOperator(Token token, std::unique_ptr<Expression> left, std::unique_ptr<Expression> right)
	: Operator(token), left(std::move(left)), right(std::move(right))
{
}
void InfixOperator::accept(Visitor &v)
{
	v.visit(*this);
}
PrefixOperator::PrefixOperator(Token token, std::unique_ptr<Expression> operand)
	: Operator(token), operand(std::move(operand))
{
}
void PrefixOperator::accept(Visitor &v)
{
	v.visit(*this);
}
PostfixOperator::PostfixOperator(Token token, std::unique_ptr<Expression> operand)
	: Operator(token), operand(std::move(operand))
{
}
void PostfixOperator::accept(Visitor &v)
{
	v.visit(*this);
}
GroupExpr::GroupExpr(Token lparen, std::unique_ptr<Expression> expr, Token rparen)
	: lparen(lparen), expr(std::move(expr)), rparen(rparen)
{
}
void GroupExpr::accept(Visitor &v)
{
	v.visit(*this);
}
ReturnExpr::ReturnExpr(Token return_keyword, std::unique_ptr<Expression> value)
	: return_keyword(return_keyword), value(std::move(value))
{
}
void ReturnExpr::accept(Visitor &v)
{
	v.visit(*this);
}
IfExpr::IfExpr(Token if_keyword, std::unique_ptr<Expression> condition, std::unique_ptr<Statement> if_branch, Token else_keyword, std::unique_ptr<Statement> else_branch)
	: if_keyword(if_keyword), condition(std::move(condition)), if_branch(std::move(if_branch)), else_keyword(else_keyword), else_branch(std::move(else_branch))
{
}
void IfExpr::accept(Visitor &v)
{
	v.visit(*this);
}
WhileExpr::WhileExpr(Token while_keyword, std::unique_ptr<Expression> condition, std::unique_ptr<Statement> body)
	: while_keyword(while_keyword), condition(std::move(condition)), body(std::move(body))
{
}
void WhileExpr::accept(Visitor &v)
{
	v.visit(*this);
}
void Invalid::accept(Visitor &v)
{
	v.visit(*this);
}
Block::Block(Token lbrace, std::vector<std::unique_ptr<Statement>> statements, Token rbrace)
	: lbrace(lbrace), statements(std::move(statements)), rbrace(rbrace)
{
}
void Block::accept(Visitor &v)
{
	v.visit(*this);
}
Parameter::Parameter(std::unique_ptr<Identifier> name, std::unique_ptr<Type> type)
	: name(std::move(name)), type(std::move(type))
{
}
void Parameter::accept(Visitor &v)
{
	v.visit(*this);
}
Type::Type(Token token)
	: token(token)
{
}
void Type::accept(Visitor &v)
{
	v.visit(*this);
}
