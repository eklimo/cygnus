// generated by nodegen.py; do not edit

#include "node.h"

Program::Program(std::vector<std::unique_ptr<Statement>> _statements)
	: statements(std::move(_statements))
{
}
void Program::accept(Visitor &v)
{
	v.visit(*this);
}
ExprStatement::ExprStatement(std::unique_ptr<Expression> _expr)
	: expr(std::move(_expr))
{
}
void ExprStatement::accept(Visitor &v)
{
	v.visit(*this);
}
VariableDef::VariableDef(std::unique_ptr<Identifier> _name, std::unique_ptr<Type> _type, std::unique_ptr<Expression> _value)
	: name(std::move(_name)), type(std::move(_type)), value(std::move(_value))
{
}
void VariableDef::accept(Visitor &v)
{
	v.visit(*this);
}
FunctionDef::FunctionDef(std::unique_ptr<Identifier> _name, std::vector<std::unique_ptr<Parameter>> _parameters, std::unique_ptr<Type> _return_type, std::unique_ptr<Block> _body)
	: name(std::move(_name)), parameters(std::move(_parameters)), return_type(std::move(_return_type)), body(std::move(_body))
{
}
void FunctionDef::accept(Visitor &v)
{
	v.visit(*this);
}
Value::Value(Token _token)
	: token(_token)
{
}
void NumberLiteral::accept(Visitor &v)
{
	v.visit(*this);
}
void StringLiteral::accept(Visitor &v)
{
	v.visit(*this);
}
void BooleanLiteral::accept(Visitor &v)
{
	v.visit(*this);
}
void UnitLiteral::accept(Visitor &v)
{
	v.visit(*this);
}
Identifier::Identifier(Token token, std::shared_ptr<SymbolData> _symbol)
	: Value(token), symbol(_symbol)
{
}
void Identifier::accept(Visitor &v)
{
	v.visit(*this);
}
FunctionCall::FunctionCall(std::unique_ptr<Identifier> _name, std::vector<std::unique_ptr<Expression>> _arguments)
	: name(std::move(_name)), arguments(std::move(_arguments))
{
}
void FunctionCall::accept(Visitor &v)
{
	v.visit(*this);
}
Operator::Operator(Token _token)
	: token(_token)
{
}
InfixOperator::InfixOperator(Token token, std::unique_ptr<Expression> _left, std::unique_ptr<Expression> _right)
	: Operator(token), left(std::move(_left)), right(std::move(_right))
{
}
void InfixOperator::accept(Visitor &v)
{
	v.visit(*this);
}
PrefixOperator::PrefixOperator(Token token, std::unique_ptr<Expression> _operand)
	: Operator(token), operand(std::move(_operand))
{
}
void PrefixOperator::accept(Visitor &v)
{
	v.visit(*this);
}
PostfixOperator::PostfixOperator(Token token, std::unique_ptr<Expression> _operand)
	: Operator(token), operand(std::move(_operand))
{
}
void PostfixOperator::accept(Visitor &v)
{
	v.visit(*this);
}
ReturnExpr::ReturnExpr(std::unique_ptr<Expression> _value)
	: value(std::move(_value))
{
}
void ReturnExpr::accept(Visitor &v)
{
	v.visit(*this);
}
IfExpr::IfExpr(std::unique_ptr<Expression> _condition, std::unique_ptr<Block> _if_branch, std::unique_ptr<Block> _else_branch)
	: condition(std::move(_condition)), if_branch(std::move(_if_branch)), else_branch(std::move(_else_branch))
{
}
void IfExpr::accept(Visitor &v)
{
	v.visit(*this);
}
WhileExpr::WhileExpr(std::unique_ptr<Expression> _condition, std::unique_ptr<Block> _body)
	: condition(std::move(_condition)), body(std::move(_body))
{
}
void WhileExpr::accept(Visitor &v)
{
	v.visit(*this);
}
void Invalid::accept(Visitor &v)
{
	v.visit(*this);
}
Block::Block(std::vector<std::unique_ptr<Statement>> _statements)
	: statements(std::move(_statements))
{
}
void Block::accept(Visitor &v)
{
	v.visit(*this);
}
Parameter::Parameter(std::unique_ptr<Identifier> _name, std::unique_ptr<Type> _type)
	: name(std::move(_name)), type(std::move(_type))
{
}
void Parameter::accept(Visitor &v)
{
	v.visit(*this);
}
Type::Type(Token _token)
	: token(_token)
{
}
void Type::accept(Visitor &v)
{
	v.visit(*this);
}
